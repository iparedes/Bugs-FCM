# Generated from /Users/nacho/Documents/python-projects/Bugs-FCM/mvasm.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\67")
        buf.write("\u0096\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\3\2")
        buf.write("\6\2\34\n\2\r\2\16\2\35\3\3\3\3\3\3\3\3\3\3\7\3%\n\3\f")
        buf.write("\3\16\3(\13\3\3\3\3\3\7\3,\n\3\f\3\16\3/\13\3\3\3\3\3")
        buf.write("\3\3\3\4\3\4\3\4\3\4\3\4\3\4\5\4:\n\4\3\5\3\5\3\5\3\5")
        buf.write("\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write("\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5q\n\5\3\6\3\6\3")
        buf.write("\6\3\6\3\6\5\6x\n\6\3\7\3\7\3\7\3\7\3\7\5\7\177\n\7\3")
        buf.write("\b\3\b\5\b\u0083\n\b\3\t\3\t\5\t\u0087\n\t\3\n\3\n\3\13")
        buf.write("\3\13\5\13\u008d\n\13\3\f\3\f\3\r\6\r\u0092\n\r\r\r\16")
        buf.write("\r\u0093\3\r\2\2\16\2\4\6\b\n\f\16\20\22\24\26\30\2\4")
        buf.write("\3\2\3\13\3\2\r\26\2\u00a6\2\33\3\2\2\2\4\37\3\2\2\2\6")
        buf.write("9\3\2\2\2\bp\3\2\2\2\nw\3\2\2\2\f~\3\2\2\2\16\u0082\3")
        buf.write("\2\2\2\20\u0086\3\2\2\2\22\u0088\3\2\2\2\24\u008c\3\2")
        buf.write("\2\2\26\u008e\3\2\2\2\30\u0091\3\2\2\2\32\34\5\4\3\2\33")
        buf.write("\32\3\2\2\2\34\35\3\2\2\2\35\33\3\2\2\2\35\36\3\2\2\2")
        buf.write("\36\3\3\2\2\2\37 \5\6\4\2 &\7\65\2\2!\"\5\b\5\2\"#\7\65")
        buf.write("\2\2#%\3\2\2\2$!\3\2\2\2%(\3\2\2\2&$\3\2\2\2&\'\3\2\2")
        buf.write("\2\')\3\2\2\2(&\3\2\2\2)-\5\b\5\2*,\7\65\2\2+*\3\2\2\2")
        buf.write(",/\3\2\2\2-+\3\2\2\2-.\3\2\2\2.\60\3\2\2\2/-\3\2\2\2\60")
        buf.write("\61\7\32\2\2\61\62\7\65\2\2\62\5\3\2\2\2\63\64\7\63\2")
        buf.write("\2\64\65\7\66\2\2\65\66\7,\2\2\66:\5\20\t\2\678\7\64\2")
        buf.write("\28:\7\66\2\29\63\3\2\2\29\67\3\2\2\2:\7\3\2\2\2;<\7!")
        buf.write("\2\2<=\5\24\13\2=>\7,\2\2>?\5\n\6\2?q\3\2\2\2@A\7(\2\2")
        buf.write("AB\5\20\t\2BC\7,\2\2CD\5\f\7\2Dq\3\2\2\2EF\7#\2\2FG\5")
        buf.write("\20\t\2GH\7,\2\2HI\5\20\t\2Iq\3\2\2\2JK\7\27\2\2KL\5\24")
        buf.write("\13\2LM\7,\2\2MN\5\20\t\2Nq\3\2\2\2OP\7&\2\2Pq\5\20\t")
        buf.write("\2QR\7$\2\2Rq\5\20\t\2ST\7\33\2\2Tq\5\24\13\2UV\7\30\2")
        buf.write("\2Vq\5\24\13\2WX\7\34\2\2Xq\7\66\2\2YZ\7\36\2\2Zq\5\30")
        buf.write("\r\2[\\\7\35\2\2\\q\5\30\r\2]^\7\37\2\2^_\5\20\t\2_`\7")
        buf.write(",\2\2`a\7\66\2\2aq\3\2\2\2bc\7 \2\2cd\5\20\t\2de\7,\2")
        buf.write("\2ef\7\66\2\2fq\3\2\2\2gq\7\'\2\2hq\7*\2\2iq\7+\2\2jk")
        buf.write("\7)\2\2kq\5\20\t\2lq\7\31\2\2mq\7\"\2\2no\7\66\2\2oq\7")
        buf.write("\61\2\2p;\3\2\2\2p@\3\2\2\2pE\3\2\2\2pJ\3\2\2\2pO\3\2")
        buf.write("\2\2pQ\3\2\2\2pS\3\2\2\2pU\3\2\2\2pW\3\2\2\2pY\3\2\2\2")
        buf.write("p[\3\2\2\2p]\3\2\2\2pb\3\2\2\2pg\3\2\2\2ph\3\2\2\2pi\3")
        buf.write("\2\2\2pj\3\2\2\2pl\3\2\2\2pm\3\2\2\2pn\3\2\2\2q\t\3\2")
        buf.write("\2\2rx\5\f\7\2st\7-\2\2tu\5\30\r\2uv\7.\2\2vx\3\2\2\2")
        buf.write("wr\3\2\2\2ws\3\2\2\2x\13\3\2\2\2y\177\5\16\b\2z{\7/\2")
        buf.write("\2{|\5\16\b\2|}\7\60\2\2}\177\3\2\2\2~y\3\2\2\2~z\3\2")
        buf.write("\2\2\177\r\3\2\2\2\u0080\u0083\5\30\r\2\u0081\u0083\5")
        buf.write("\20\t\2\u0082\u0080\3\2\2\2\u0082\u0081\3\2\2\2\u0083")
        buf.write("\17\3\2\2\2\u0084\u0087\5\24\13\2\u0085\u0087\5\26\f\2")
        buf.write("\u0086\u0084\3\2\2\2\u0086\u0085\3\2\2\2\u0087\21\3\2")
        buf.write("\2\2\u0088\u0089\t\2\2\2\u0089\23\3\2\2\2\u008a\u008d")
        buf.write("\5\22\n\2\u008b\u008d\7\f\2\2\u008c\u008a\3\2\2\2\u008c")
        buf.write("\u008b\3\2\2\2\u008d\25\3\2\2\2\u008e\u008f\t\3\2\2\u008f")
        buf.write("\27\3\2\2\2\u0090\u0092\7\62\2\2\u0091\u0090\3\2\2\2\u0092")
        buf.write("\u0093\3\2\2\2\u0093\u0091\3\2\2\2\u0093\u0094\3\2\2\2")
        buf.write("\u0094\31\3\2\2\2\r\35&-9pw~\u0082\u0086\u008c\u0093")
        return buf.getvalue()


class mvasmParser ( Parser ):

    grammarFileName = "mvasm.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'R1'", "'R2'", "'R3'", "'R4'", "'R5'", 
                     "'R6'", "'R7'", "'R8'", "'R9'", "'SRF'", "'CS'", "'CH'", 
                     "'DS'", "'PC'", "'SP'", "'PS'", "'SRR'", "'DRS'", "'NRG'", 
                     "'STM'", "'ADD'", "'DEC'", "'EAT'", "'END'", "'INC'", 
                     "'JMP'", "'JMPB'", "'JMPF'", "'JZ'", "'JNZ'", "'LD'", 
                     "'NOP'", "'MOV'", "'POP'", "'PROGRAM'", "'PUSH'", "'SRCF'", 
                     "'ST'", "'WLK'", "'WLKT'", "'WLKW'", "','", "'('", 
                     "')'", "'{'", "'}'", "':'", "<INVALID>", "'SENSOR'", 
                     "'ACTOR'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "ADD", "DEC", "EAT", "END", "INC", "JMP", 
                      "JMPB", "JMPF", "JZ", "JNZ", "LD", "NOP", "MOV", "POP", 
                      "PROGRAM", "PSH", "SRCF", "ST", "WLK", "WLKT", "WLKW", 
                      "COMMA", "OPAR", "CPAR", "OBRACE", "CBRACE", "COLON", 
                      "DIGIT", "SENSOR", "ACTOR", "NEWLINE", "VARIABLE", 
                      "WS" ]

    RULE_programs = 0
    RULE_program = 1
    RULE_prog_type = 2
    RULE_instr = 3
    RULE_val = 4
    RULE_mem = 5
    RULE_address = 6
    RULE_reg = 7
    RULE_gen_reg = 8
    RULE_wrt_reg = 9
    RULE_prt_reg = 10
    RULE_number = 11

    ruleNames =  [ "programs", "program", "prog_type", "instr", "val", "mem", 
                   "address", "reg", "gen_reg", "wrt_reg", "prt_reg", "number" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    ADD=21
    DEC=22
    EAT=23
    END=24
    INC=25
    JMP=26
    JMPB=27
    JMPF=28
    JZ=29
    JNZ=30
    LD=31
    NOP=32
    MOV=33
    POP=34
    PROGRAM=35
    PSH=36
    SRCF=37
    ST=38
    WLK=39
    WLKT=40
    WLKW=41
    COMMA=42
    OPAR=43
    CPAR=44
    OBRACE=45
    CBRACE=46
    COLON=47
    DIGIT=48
    SENSOR=49
    ACTOR=50
    NEWLINE=51
    VARIABLE=52
    WS=53

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def program(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mvasmParser.ProgramContext)
            else:
                return self.getTypedRuleContext(mvasmParser.ProgramContext,i)


        def getRuleIndex(self):
            return mvasmParser.RULE_programs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrograms" ):
                listener.enterPrograms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrograms" ):
                listener.exitPrograms(self)




    def programs(self):

        localctx = mvasmParser.ProgramsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_programs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 25 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 24
                self.program()
                self.state = 27 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==mvasmParser.SENSOR or _la==mvasmParser.ACTOR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prog_type(self):
            return self.getTypedRuleContext(mvasmParser.Prog_typeContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(mvasmParser.NEWLINE)
            else:
                return self.getToken(mvasmParser.NEWLINE, i)

        def instr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mvasmParser.InstrContext)
            else:
                return self.getTypedRuleContext(mvasmParser.InstrContext,i)


        def END(self):
            return self.getToken(mvasmParser.END, 0)

        def getRuleIndex(self):
            return mvasmParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = mvasmParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 29
            self.prog_type()
            self.state = 30
            self.match(mvasmParser.NEWLINE)
            self.state = 36
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 31
                    self.instr()
                    self.state = 32
                    self.match(mvasmParser.NEWLINE) 
                self.state = 38
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

            self.state = 39
            self.instr()
            self.state = 43
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==mvasmParser.NEWLINE:
                self.state = 40
                self.match(mvasmParser.NEWLINE)
                self.state = 45
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 46
            self.match(mvasmParser.END)
            self.state = 47
            self.match(mvasmParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Prog_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SENSOR(self):
            return self.getToken(mvasmParser.SENSOR, 0)

        def VARIABLE(self):
            return self.getToken(mvasmParser.VARIABLE, 0)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)

        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)


        def ACTOR(self):
            return self.getToken(mvasmParser.ACTOR, 0)

        def getRuleIndex(self):
            return mvasmParser.RULE_prog_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg_type" ):
                listener.enterProg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg_type" ):
                listener.exitProg_type(self)




    def prog_type(self):

        localctx = mvasmParser.Prog_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_prog_type)
        try:
            self.state = 55
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.SENSOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 49
                self.match(mvasmParser.SENSOR)
                self.state = 50
                self.match(mvasmParser.VARIABLE)
                self.state = 51
                self.match(mvasmParser.COMMA)
                self.state = 52
                self.reg()
                pass
            elif token in [mvasmParser.ACTOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 53
                self.match(mvasmParser.ACTOR)
                self.state = 54
                self.match(mvasmParser.VARIABLE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return mvasmParser.RULE_instr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class InstrwlkWContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WLKW(self):
            return self.getToken(mvasmParser.WLKW, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrwlkW" ):
                listener.enterInstrwlkW(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrwlkW" ):
                listener.exitInstrwlkW(self)


    class InstrSTContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ST(self):
            return self.getToken(mvasmParser.ST, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)
        def mem(self):
            return self.getTypedRuleContext(mvasmParser.MemContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrST" ):
                listener.enterInstrST(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrST" ):
                listener.exitInstrST(self)


    class InstrPSHContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PSH(self):
            return self.getToken(mvasmParser.PSH, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrPSH" ):
                listener.enterInstrPSH(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrPSH" ):
                listener.exitInstrPSH(self)


    class InstrADDContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ADD(self):
            return self.getToken(mvasmParser.ADD, 0)
        def wrt_reg(self):
            return self.getTypedRuleContext(mvasmParser.Wrt_regContext,0)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrADD" ):
                listener.enterInstrADD(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrADD" ):
                listener.exitInstrADD(self)


    class InstrLDContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LD(self):
            return self.getToken(mvasmParser.LD, 0)
        def wrt_reg(self):
            return self.getTypedRuleContext(mvasmParser.Wrt_regContext,0)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)
        def val(self):
            return self.getTypedRuleContext(mvasmParser.ValContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrLD" ):
                listener.enterInstrLD(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrLD" ):
                listener.exitInstrLD(self)


    class InstrWLKTContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WLKT(self):
            return self.getToken(mvasmParser.WLKT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrWLKT" ):
                listener.enterInstrWLKT(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrWLKT" ):
                listener.exitInstrWLKT(self)


    class InstrDECContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DEC(self):
            return self.getToken(mvasmParser.DEC, 0)
        def wrt_reg(self):
            return self.getTypedRuleContext(mvasmParser.Wrt_regContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrDEC" ):
                listener.enterInstrDEC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrDEC" ):
                listener.exitInstrDEC(self)


    class InstrLabelContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VARIABLE(self):
            return self.getToken(mvasmParser.VARIABLE, 0)
        def COLON(self):
            return self.getToken(mvasmParser.COLON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrLabel" ):
                listener.enterInstrLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrLabel" ):
                listener.exitInstrLabel(self)


    class InstrINCContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INC(self):
            return self.getToken(mvasmParser.INC, 0)
        def wrt_reg(self):
            return self.getTypedRuleContext(mvasmParser.Wrt_regContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrINC" ):
                listener.enterInstrINC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrINC" ):
                listener.exitInstrINC(self)


    class InstrSRCFContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SRCF(self):
            return self.getToken(mvasmParser.SRCF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrSRCF" ):
                listener.enterInstrSRCF(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrSRCF" ):
                listener.exitInstrSRCF(self)


    class InstrEATContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EAT(self):
            return self.getToken(mvasmParser.EAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrEAT" ):
                listener.enterInstrEAT(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrEAT" ):
                listener.exitInstrEAT(self)


    class InstrJZContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JZ(self):
            return self.getToken(mvasmParser.JZ, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)
        def VARIABLE(self):
            return self.getToken(mvasmParser.VARIABLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrJZ" ):
                listener.enterInstrJZ(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrJZ" ):
                listener.exitInstrJZ(self)


    class InstrMOVContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MOV(self):
            return self.getToken(mvasmParser.MOV, 0)
        def reg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(mvasmParser.RegContext)
            else:
                return self.getTypedRuleContext(mvasmParser.RegContext,i)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrMOV" ):
                listener.enterInstrMOV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrMOV" ):
                listener.exitInstrMOV(self)


    class InstrJNZContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JNZ(self):
            return self.getToken(mvasmParser.JNZ, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)

        def COMMA(self):
            return self.getToken(mvasmParser.COMMA, 0)
        def VARIABLE(self):
            return self.getToken(mvasmParser.VARIABLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrJNZ" ):
                listener.enterInstrJNZ(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrJNZ" ):
                listener.exitInstrJNZ(self)


    class InstrWLKContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WLK(self):
            return self.getToken(mvasmParser.WLK, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrWLK" ):
                listener.enterInstrWLK(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrWLK" ):
                listener.exitInstrWLK(self)


    class InstrPOPContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def POP(self):
            return self.getToken(mvasmParser.POP, 0)
        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrPOP" ):
                listener.enterInstrPOP(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrPOP" ):
                listener.exitInstrPOP(self)


    class InstrJMPBContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JMPB(self):
            return self.getToken(mvasmParser.JMPB, 0)
        def number(self):
            return self.getTypedRuleContext(mvasmParser.NumberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrJMPB" ):
                listener.enterInstrJMPB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrJMPB" ):
                listener.exitInstrJMPB(self)


    class InstrJMPContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JMP(self):
            return self.getToken(mvasmParser.JMP, 0)
        def VARIABLE(self):
            return self.getToken(mvasmParser.VARIABLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrJMP" ):
                listener.enterInstrJMP(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrJMP" ):
                listener.exitInstrJMP(self)


    class InstrNOPContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOP(self):
            return self.getToken(mvasmParser.NOP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrNOP" ):
                listener.enterInstrNOP(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrNOP" ):
                listener.exitInstrNOP(self)


    class InstrJMPFContext(InstrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.InstrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JMPF(self):
            return self.getToken(mvasmParser.JMPF, 0)
        def number(self):
            return self.getTypedRuleContext(mvasmParser.NumberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstrJMPF" ):
                listener.enterInstrJMPF(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstrJMPF" ):
                listener.exitInstrJMPF(self)



    def instr(self):

        localctx = mvasmParser.InstrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_instr)
        try:
            self.state = 110
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.LD]:
                localctx = mvasmParser.InstrLDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 57
                self.match(mvasmParser.LD)
                self.state = 58
                self.wrt_reg()
                self.state = 59
                self.match(mvasmParser.COMMA)
                self.state = 60
                self.val()
                pass
            elif token in [mvasmParser.ST]:
                localctx = mvasmParser.InstrSTContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 62
                self.match(mvasmParser.ST)
                self.state = 63
                self.reg()
                self.state = 64
                self.match(mvasmParser.COMMA)
                self.state = 65
                self.mem()
                pass
            elif token in [mvasmParser.MOV]:
                localctx = mvasmParser.InstrMOVContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 67
                self.match(mvasmParser.MOV)
                self.state = 68
                self.reg()
                self.state = 69
                self.match(mvasmParser.COMMA)
                self.state = 70
                self.reg()
                pass
            elif token in [mvasmParser.ADD]:
                localctx = mvasmParser.InstrADDContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 72
                self.match(mvasmParser.ADD)
                self.state = 73
                self.wrt_reg()
                self.state = 74
                self.match(mvasmParser.COMMA)
                self.state = 75
                self.reg()
                pass
            elif token in [mvasmParser.PSH]:
                localctx = mvasmParser.InstrPSHContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 77
                self.match(mvasmParser.PSH)
                self.state = 78
                self.reg()
                pass
            elif token in [mvasmParser.POP]:
                localctx = mvasmParser.InstrPOPContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 79
                self.match(mvasmParser.POP)
                self.state = 80
                self.reg()
                pass
            elif token in [mvasmParser.INC]:
                localctx = mvasmParser.InstrINCContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 81
                self.match(mvasmParser.INC)
                self.state = 82
                self.wrt_reg()
                pass
            elif token in [mvasmParser.DEC]:
                localctx = mvasmParser.InstrDECContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 83
                self.match(mvasmParser.DEC)
                self.state = 84
                self.wrt_reg()
                pass
            elif token in [mvasmParser.JMP]:
                localctx = mvasmParser.InstrJMPContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 85
                self.match(mvasmParser.JMP)
                self.state = 86
                self.match(mvasmParser.VARIABLE)
                pass
            elif token in [mvasmParser.JMPF]:
                localctx = mvasmParser.InstrJMPFContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 87
                self.match(mvasmParser.JMPF)
                self.state = 88
                self.number()
                pass
            elif token in [mvasmParser.JMPB]:
                localctx = mvasmParser.InstrJMPBContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 89
                self.match(mvasmParser.JMPB)
                self.state = 90
                self.number()
                pass
            elif token in [mvasmParser.JZ]:
                localctx = mvasmParser.InstrJZContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 91
                self.match(mvasmParser.JZ)
                self.state = 92
                self.reg()
                self.state = 93
                self.match(mvasmParser.COMMA)
                self.state = 94
                self.match(mvasmParser.VARIABLE)
                pass
            elif token in [mvasmParser.JNZ]:
                localctx = mvasmParser.InstrJNZContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 96
                self.match(mvasmParser.JNZ)
                self.state = 97
                self.reg()
                self.state = 98
                self.match(mvasmParser.COMMA)
                self.state = 99
                self.match(mvasmParser.VARIABLE)
                pass
            elif token in [mvasmParser.SRCF]:
                localctx = mvasmParser.InstrSRCFContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 101
                self.match(mvasmParser.SRCF)
                pass
            elif token in [mvasmParser.WLKT]:
                localctx = mvasmParser.InstrWLKTContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 102
                self.match(mvasmParser.WLKT)
                pass
            elif token in [mvasmParser.WLKW]:
                localctx = mvasmParser.InstrwlkWContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 103
                self.match(mvasmParser.WLKW)
                pass
            elif token in [mvasmParser.WLK]:
                localctx = mvasmParser.InstrWLKContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 104
                self.match(mvasmParser.WLK)
                self.state = 105
                self.reg()
                pass
            elif token in [mvasmParser.EAT]:
                localctx = mvasmParser.InstrEATContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 106
                self.match(mvasmParser.EAT)
                pass
            elif token in [mvasmParser.NOP]:
                localctx = mvasmParser.InstrNOPContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 107
                self.match(mvasmParser.NOP)
                pass
            elif token in [mvasmParser.VARIABLE]:
                localctx = mvasmParser.InstrLabelContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 108
                self.match(mvasmParser.VARIABLE)
                self.state = 109
                self.match(mvasmParser.COLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return mvasmParser.RULE_val

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ValmemContext(ValContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.ValContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def mem(self):
            return self.getTypedRuleContext(mvasmParser.MemContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValmem" ):
                listener.enterValmem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValmem" ):
                listener.exitValmem(self)


    class ValnumberContext(ValContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.ValContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPAR(self):
            return self.getToken(mvasmParser.OPAR, 0)
        def number(self):
            return self.getTypedRuleContext(mvasmParser.NumberContext,0)

        def CPAR(self):
            return self.getToken(mvasmParser.CPAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValnumber" ):
                listener.enterValnumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValnumber" ):
                listener.exitValnumber(self)



    def val(self):

        localctx = mvasmParser.ValContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_val)
        try:
            self.state = 117
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.T__0, mvasmParser.T__1, mvasmParser.T__2, mvasmParser.T__3, mvasmParser.T__4, mvasmParser.T__5, mvasmParser.T__6, mvasmParser.T__7, mvasmParser.T__8, mvasmParser.T__9, mvasmParser.T__10, mvasmParser.T__11, mvasmParser.T__12, mvasmParser.T__13, mvasmParser.T__14, mvasmParser.T__15, mvasmParser.T__16, mvasmParser.T__17, mvasmParser.T__18, mvasmParser.T__19, mvasmParser.OBRACE, mvasmParser.DIGIT]:
                localctx = mvasmParser.ValmemContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 112
                self.mem()
                pass
            elif token in [mvasmParser.OPAR]:
                localctx = mvasmParser.ValnumberContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 113
                self.match(mvasmParser.OPAR)
                self.state = 114
                self.number()
                self.state = 115
                self.match(mvasmParser.CPAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return mvasmParser.RULE_mem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class MemRelContext(MemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.MemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def address(self):
            return self.getTypedRuleContext(mvasmParser.AddressContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemRel" ):
                listener.enterMemRel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemRel" ):
                listener.exitMemRel(self)


    class MemAbsContext(MemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a mvasmParser.MemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OBRACE(self):
            return self.getToken(mvasmParser.OBRACE, 0)
        def address(self):
            return self.getTypedRuleContext(mvasmParser.AddressContext,0)

        def CBRACE(self):
            return self.getToken(mvasmParser.CBRACE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemAbs" ):
                listener.enterMemAbs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemAbs" ):
                listener.exitMemAbs(self)



    def mem(self):

        localctx = mvasmParser.MemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_mem)
        try:
            self.state = 124
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.T__0, mvasmParser.T__1, mvasmParser.T__2, mvasmParser.T__3, mvasmParser.T__4, mvasmParser.T__5, mvasmParser.T__6, mvasmParser.T__7, mvasmParser.T__8, mvasmParser.T__9, mvasmParser.T__10, mvasmParser.T__11, mvasmParser.T__12, mvasmParser.T__13, mvasmParser.T__14, mvasmParser.T__15, mvasmParser.T__16, mvasmParser.T__17, mvasmParser.T__18, mvasmParser.T__19, mvasmParser.DIGIT]:
                localctx = mvasmParser.MemRelContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 119
                self.address()
                pass
            elif token in [mvasmParser.OBRACE]:
                localctx = mvasmParser.MemAbsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 120
                self.match(mvasmParser.OBRACE)
                self.state = 121
                self.address()
                self.state = 122
                self.match(mvasmParser.CBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddressContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(mvasmParser.NumberContext,0)


        def reg(self):
            return self.getTypedRuleContext(mvasmParser.RegContext,0)


        def getRuleIndex(self):
            return mvasmParser.RULE_address

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddress" ):
                listener.enterAddress(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddress" ):
                listener.exitAddress(self)




    def address(self):

        localctx = mvasmParser.AddressContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_address)
        try:
            self.state = 128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.DIGIT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 126
                self.number()
                pass
            elif token in [mvasmParser.T__0, mvasmParser.T__1, mvasmParser.T__2, mvasmParser.T__3, mvasmParser.T__4, mvasmParser.T__5, mvasmParser.T__6, mvasmParser.T__7, mvasmParser.T__8, mvasmParser.T__9, mvasmParser.T__10, mvasmParser.T__11, mvasmParser.T__12, mvasmParser.T__13, mvasmParser.T__14, mvasmParser.T__15, mvasmParser.T__16, mvasmParser.T__17, mvasmParser.T__18, mvasmParser.T__19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 127
                self.reg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def wrt_reg(self):
            return self.getTypedRuleContext(mvasmParser.Wrt_regContext,0)


        def prt_reg(self):
            return self.getTypedRuleContext(mvasmParser.Prt_regContext,0)


        def getRuleIndex(self):
            return mvasmParser.RULE_reg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReg" ):
                listener.enterReg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReg" ):
                listener.exitReg(self)




    def reg(self):

        localctx = mvasmParser.RegContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_reg)
        try:
            self.state = 132
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.T__0, mvasmParser.T__1, mvasmParser.T__2, mvasmParser.T__3, mvasmParser.T__4, mvasmParser.T__5, mvasmParser.T__6, mvasmParser.T__7, mvasmParser.T__8, mvasmParser.T__9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 130
                self.wrt_reg()
                pass
            elif token in [mvasmParser.T__10, mvasmParser.T__11, mvasmParser.T__12, mvasmParser.T__13, mvasmParser.T__14, mvasmParser.T__15, mvasmParser.T__16, mvasmParser.T__17, mvasmParser.T__18, mvasmParser.T__19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self.prt_reg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Gen_regContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return mvasmParser.RULE_gen_reg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGen_reg" ):
                listener.enterGen_reg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGen_reg" ):
                listener.exitGen_reg(self)




    def gen_reg(self):

        localctx = mvasmParser.Gen_regContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_gen_reg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << mvasmParser.T__0) | (1 << mvasmParser.T__1) | (1 << mvasmParser.T__2) | (1 << mvasmParser.T__3) | (1 << mvasmParser.T__4) | (1 << mvasmParser.T__5) | (1 << mvasmParser.T__6) | (1 << mvasmParser.T__7) | (1 << mvasmParser.T__8))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Wrt_regContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gen_reg(self):
            return self.getTypedRuleContext(mvasmParser.Gen_regContext,0)


        def getRuleIndex(self):
            return mvasmParser.RULE_wrt_reg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWrt_reg" ):
                listener.enterWrt_reg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWrt_reg" ):
                listener.exitWrt_reg(self)




    def wrt_reg(self):

        localctx = mvasmParser.Wrt_regContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_wrt_reg)
        try:
            self.state = 138
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [mvasmParser.T__0, mvasmParser.T__1, mvasmParser.T__2, mvasmParser.T__3, mvasmParser.T__4, mvasmParser.T__5, mvasmParser.T__6, mvasmParser.T__7, mvasmParser.T__8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.gen_reg()
                pass
            elif token in [mvasmParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 137
                self.match(mvasmParser.T__9)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Prt_regContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return mvasmParser.RULE_prt_reg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrt_reg" ):
                listener.enterPrt_reg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrt_reg" ):
                listener.exitPrt_reg(self)




    def prt_reg(self):

        localctx = mvasmParser.Prt_regContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_prt_reg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << mvasmParser.T__10) | (1 << mvasmParser.T__11) | (1 << mvasmParser.T__12) | (1 << mvasmParser.T__13) | (1 << mvasmParser.T__14) | (1 << mvasmParser.T__15) | (1 << mvasmParser.T__16) | (1 << mvasmParser.T__17) | (1 << mvasmParser.T__18) | (1 << mvasmParser.T__19))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(mvasmParser.DIGIT)
            else:
                return self.getToken(mvasmParser.DIGIT, i)

        def getRuleIndex(self):
            return mvasmParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = mvasmParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 142
                self.match(mvasmParser.DIGIT)
                self.state = 145 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==mvasmParser.DIGIT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





